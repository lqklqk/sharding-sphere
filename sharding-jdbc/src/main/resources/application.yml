

spring:
  data:
    redis:
      host: 192.168.1.196 #redis服务器地址
      port: 6379  #redis服务器端口号
      database: 0 #默认使用0号数据库（数据库索引）
      timeout: 1800000  #连接超时时间（毫秒）
      lettuce:
        pool:
          max-active: 20  #连接池最大连接数（使用负值表示没有限制）
          max-wait: -1  #最大阻塞等待时间（负数表示没有限制）
          max-idle: 5 #连接池中的最大空闲连接
          min-idle: 0 #连接池中的最小空闲连接
  application:
    name: sharding-jdbc
  shardingsphere:
    enabled: true
    datasource:
      names: db0,db1
      db0:
        type: com.alibaba.druid.pool.DruidDataSource
        url: jdbc:mysql://192.168.1.196:3306/shardingdb1?serverTimezone=GMT%2B8
        driver-class-name: com.mysql.cj.jdbc.Driver
        username: root
        password: 123456
      db1:
        type: com.alibaba.druid.pool.DruidDataSource
        url: jdbc:mysql://192.168.1.196:3306/shardingdb2?serverTimezone=GMT%2B8
        driver-class-name: com.mysql.cj.jdbc.Driver
        username: root
        password: 123456
    rules:
      # 数据分片
      sharding:
        # 自定义自动分片路由策略配置
        auto-assign-route-strategy: least
        key-generators:
          snowflake:
            type: snowflake
            props:
              worker-id: 1
          # 自定义主键生成策略
          user-redis-key-generator:
            type: redisSharding
            props:
              strategy-key: user
          user-split-key-generator:
            type: redisSharding
            props:
              strategy-key: user_split
          dict-key-generator:
            type: redisSharding
            props:
              strategy-key: dict
          sharding-route-key-generator:
            type: redisSharding
            props:
              strategy-key: sharding_route
          user-course-info-key-generator:
            type: redisSharding
            props:
              strategy-key: user_course_info
        tables:
          sharding_route:
            actual-data-nodes: db$->{0..1}.sharding_route
            key-generate-strategy:
              column: id
              key-generator-name: sharding-route-key-generator
          # 基础分库分表测试案例
          course:
            # 真实表分布
            actual-data-nodes: db$->{0..1}.course_$->{1..2}
            # 主键生成策略，分布式主键生成算法
            key-generate-strategy:
              column: cid
              key-generator-name: snowflake
            # 分库策略
            database-strategy:
              standard:
                sharding-column: cid
                sharding-algorithm-name: course_db_alg
            table-strategy:
              # 标准分片策略
              standard:
                sharding-column: cid
                sharding-algorithm-name: course_tbl_alg
            # 分片审计策略
            audit-strategy:
              auditor-names:
                - course_auditor
              # 表示分片审计允许对hint分片策略禁用
              allow-hint-disable: true
              # 复合分片策略
#              complex:
#                sharding-columns: cid,user_id
#                sharding-algorithm-name: course_tbl_alg
              # 强制分片
#              hint:
#                sharding-algorithm-name: course_tbl_alg
          # 自定义主键、数据加密测试案例
          user:
            # 真实表分布
            actual-data-nodes: db$->{0..1}.user_$->{1..2}
            # 主键生成策略，分布式主键生成算法
#            key-generate-strategy:
#              column: userid
#              key-generator-name: user-redis-key-generator
            # 分库策略
            database-strategy:
              standard:
                sharding-column: userid
                sharding-algorithm-name: user_db_alg
            table-strategy:
              standard:
                sharding-column: userid
                sharding-algorithm-name: user_tbl_alg
          # 分库分表测试案例
          user_split:
            # 配置读写分的虚拟库
            actual-data-nodes: userdb.user_split
            key-generate-strategy:
              column: userid
              key-generator-name: user-split-key-generator
          # 广播表案例
          dict:
            actual-data-nodes: db$->{0..1}.dict
            key-generate-strategy:
              column: dict_id
              key-generator-name: dict-key-generator
          # 绑定表案例
          user_course_info:
            # 真实表分布
            actual-data-nodes: db$->{0..1}.user_course_info_$->{1..2}
            # 主键生成策略，分布式主键生成算法
            key-generate-strategy:
              column: infoid
              key-generator-name: user-course-info-key-generator
            # 分库策略--与user表一致（与user表进行绑定）
            database-strategy:
              standard:
                sharding-column: userid
                sharding-algorithm-name: user_db_alg
            table-strategy:
              standard:
                sharding-column: userid
                sharding-algorithm-name: user_tbl_alg
        # 分库配置分片算法
        sharding-algorithms:
          course_db_alg:
            type: MOD
            props:
              # 基于取模的分片算法
              sharding-count: 2
          user_db_alg:
            type: HASH_MOD
            props:
              # 基于取模的分片算法
              sharding-count: 2
          # 分表算法
          course_tbl_alg:
            type: INLINE
            props:
              # 基于行表达式的分片算法
              algorithm-expression: course_$->{cid % 2 + 1}
              allow-range-query-with-inline-sharding: true
#          course_tbl_alg:
#            # 复合分片算法
#            type: COMPLEX_INLINE
#            props:
#              algorithm-expression: course_$->{(cid+user_id+1)%2+1}
#              allow-range-query-with-inline-sharding: true
          user_tbl_alg:
            type: CLASS_BASED
            props:
              strategy: STANDARD
              algorithmClassName: com.lqk.shardingjdbc.config.sharding.algorithem.UserStandardShardingAlgorithm
#          course_tbl_alg:
#            type: HINT_INLINE
#            props:
#              algorithm-expression: course_${value}
        # 指定广播表。广播表会忽略分表逻辑，每个分库中的表中插入数据
        broadcast-tables: dict,sharding_route
        binding-tables:
          - user,user_course_info
        # 分片审计策略
        auditors:
          course_auditor:
            # 对逻辑表查询时，必须带上分片键
            type: DML_SHARDING_CONDITIONS
      # 数据加密
      encrypt:
        tables:
          user:
            columns:
              password:
                # 存储明文的列
                plain-column: password
                # 存储密文的列
                cipher-column: password_cipher
                # 加密器名称
                encryptor-name: user_password_encry
        # 加密器
        encryptors:
          user_password_encry:
            type: AES
            props:
              aes-key-value: 123456
          user_password_encry2:
            type: MD5
          user_password_encry3:
            type: SM3
            props:
              sm3-salt: 12345678
          user_password_encry4:
            type: SM4
            props:
              sm4-key: 86C63180C2806ED1F43A859DE501215C
              sm4-mode: ECB
              sm4-padding: PKCS5Padding
          user_password_encry5:
            type: RC4
            props:
              rc4-key-value: 12345678
      # 读写分离
      readwrite-splitting:
        data-sources:
          # 配置读写分离，一个主库（写库），多个从库（读库）
          userdb:
            static-strategy:
              write-data-source-name: db0
              read-data-source-names:
                - db1
            load-balancer-name: user-split-lb
        load-balancers:
          user-split-lb:
            # 按操作轮询
            type: ROUND_ROBIN
            # 该算法不需要配置
            props:
              test-key: 1
#            # 按事务轮询
#            type: TRANSACTION_ROUND_ROBIN
#            # 按操作随机
#            type: RANDOM
#            # 按事务随机
#            type: TRANSACTION_RANDOM
#            # 读请求全部强制路由到主库
#            type: FIXED_PRIMARY
    # 显示原sql、拆解后的sql
    props:
      sql-show: true
  main:
    allow-bean-definition-overriding: true

#spring:
#  datasource:
#    druid:
#      db-type: mysql
#      driver-class-name: com.mysql.cj.jdbc.Driver
#      url: jdbc:mysql://192.168.1.196:3306/shardingdb1?serverTimezone=GMT%2B8
#      username: root
#      password: 123456

mybatis-plus:
  mapper-locations: classpath:mybatis/mapper/**/*.xml

